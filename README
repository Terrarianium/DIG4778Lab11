How does each pathfinding algorithms calculate and prioritize paths?
BFS pathfinding works by using a queue to do check in every direction from each vertex. When it checks a direction, it adds the vertex in that dirction to queue. It uses a dictionary to keep from checking nodes that it has already been to. This means that it doesn't prioritize any path, checking all possible
paths equally. A* pathfinding works similarly to BFS, but it uses a priority queue and another dictionary to dictate a cost for each possible movement. It uses a heuristic function that works based on the distance to the goal to add priotiry to each possible move. This makes the queue only choose the vertices
with the highest priority first, leading to a faster goal finding. Dijkstra pathfinding is like A* but without the heuristic function. This means its functionally the same as BFS on a graph where all vertices have equal cost, but will work better in a graph where vertices have different costs.

What challenges arise when dynamically updating obstacles in real-time?
One challenge that could arise is that if a vertex is marked as cameFrom is turned into an obstacle, the path could mistakenly use that vertex as a path even though it has been turned into an obstacle.

Which algorithm should you choose and how should you adapt it for larger grids or open-world settings?
You should choose A* since it uses heuristic to determine the cheapest route to take, and would figure it out the fastest. You should adapt it by giving some grids a higher cost, so it will find the shortest path to getting from point A to B.

What would your approach be if you were to add weighted cells (e.g., "difficult terrain" areas)?
If we were to add weighted cells, we would make each "terrain" have a different negative value, and search for the path that returns the highest possible value.
